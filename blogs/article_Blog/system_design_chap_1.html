<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Buya's Portfolio</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/7.0.0/normalize.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.css"
        integrity="sha256-46qynGAkLSFpVbEBog43gvNhfrOj+BmwXdxFgVK/Kvc=" crossorigin="anonymous" />
    <link href="https://fonts.googleapis.com/css?family=Lora:400,700|Roboto+Slab:400,700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../../css/style.css">
    <link rel="stylesheet" href="../blogs.css">
    <script src="https://code.iconify.design/2/2.2.1/iconify.min.js"></script>
</head>

<body>
    <ul class="sticky" id="mainMenu">
        <li class="mainMenuList"><a href="../../index.html">Home</a></li>
        <li class="mainMenuList"><a href="../../index.html#project">Project</a></li>
        <li class="mainMenuList"><a href="../../index.html#class">Online class</a></li>
        <li class="mainMenuList"><a href="../../index.html#competition">Competition</a></li>
        <li class="mainMenuList"><a href="../../index.html#about">About me</a></li>
        <li class="mainMenuList"><a href="../blogs.html">Blog</a></li>
    </ul>

    <div class="container">
        <div class="blog_section blog-post">
            <div class="blog-post-header">
                <img src="../../img/myAvatar1.png" alt="Author avatar" class="blog-avatar">
                <div>
                    <h1 class="blog-title">Breaking Down Chapter 1 of System Design Interview by Alex Xu</h1>
                    <div class="blog-meta">By Buya &bull; <span>August 2025</span></div>
                </div>
            </div>
            <span class="blog-badge">System Design</span>

            <p>A Practical Guide to Core System Design Concepts</p>
            
            <p>If you're starting your journey into system design, Alex Xu's <strong>System Design Interview</strong> is one of the most widely recommended books. Chapter 1 is more than an introduction‚Äîit's a foundation. It outlines the fundamental building blocks of large-scale systems and explains how they interact to handle millions of users reliably.</p>

            <p>I revisited this chapter recently, and here's a deep-dive summary with a few additional insights beyond the book's main points.</p>
            <hr class="blog-divider">

            <h4>üóÑÔ∏è 1. Databases: SQL vs. NoSQL</h4>
            <p>Every system starts with data‚Äîand the database is where it lives.</p>

            <h5><strong>SQL Databases</strong> (e.g., MySQL, PostgreSQL)</h5>
            <ul>
                <li>Store data in tables and rows with a fixed schema.</li>
                <li>Strong consistency and relational integrity.</li>
                <li>Excellent for complex queries and transactions (e.g., banking).</li>
            </ul>

            <h5><strong>NoSQL Databases</strong></h5>
            <p>Designed for scalability, flexible schemas, and massive datasets. Types include:</p>
            <ul>
                <li><strong>Key-Value Stores</strong> (e.g., Redis) ‚Äì lightning-fast lookups.</li>
                <li><strong>Document Stores</strong> (e.g., MongoDB) ‚Äì store semi-structured JSON-like documents.</li>
            </ul>

            <hr class="blog-divider">

            <h4>üìà 2. Scaling: Vertical vs. Horizontal</h4>
            <p>When your user base grows, your system needs to grow with it.</p>

            <h5><strong>Vertical Scaling (Scale Up)</strong></h5>
            <ul>
                <li>Add CPU, RAM, or faster disks to a single machine.</li>
                <li>‚úÖ Simple to implement.</li>
                <li>‚ùå Expensive, with physical limits.</li>
            </ul>

            <h5><strong>Horizontal Scaling (Scale Out)</strong></h5>
            <ul>
                <li>Add more servers to share the workload.</li>
                <li>‚úÖ Higher fault tolerance.</li>
                <li>‚ùå Requires careful coordination (data distribution, consistency).</li>
            </ul>

            <hr class="blog-divider">

            <h4>‚öñÔ∏è 3. Load Balancers</h4>
            <p>A load balancer acts like the receptionist of your system: it decides where each request should go.</p>
            <ul>
                <li>Routes traffic across multiple servers using algorithms like round robin, least connections, or IP hash.</li>
                <li>Improves reliability‚Äîif one server fails, traffic is rerouted.</li>
                <li>Supports auto-scaling by adding/removing servers as needed.</li>
            </ul>
            <hr class="blog-divider">

            <h4>üîÑ 4. Database Replication</h4>
            <p>Replication improves both availability and read performance.</p>

            <h5><strong>Master-Slave Replication</strong></h5>
            <ul>
                <li>Master handles writes.</li>
                <li>Slaves handle reads.</li>
                <li>Helps distribute load and protect against data loss.</li>
            </ul>

            <p><strong>Caveat:</strong> Replication lag can cause stale reads or inconsistencies when a slave becomes the master.</p>
            <hr class="blog-divider">

            <h4>‚ö° 5. Caching</h4>
            <p>Caching stores frequently accessed data in-memory for fast retrieval.</p>
            <ul>
                <li>Reduces load on the database.</li>
                <li>Can be placed at multiple layers: browser, CDN, application, or database.</li>
                <li>Use cache invalidation strategies (e.g., TTL, write-through) to avoid serving outdated data.</li>
            </ul>

            <p>‚ö† <strong>Single Point of Failure:</strong> If your only cache server fails, performance can drop sharply. Use replication or sharding for resilience.</p>
            <hr class="blog-divider">

            <h4>üåê 6. Content Delivery Networks (CDNs)</h4>
            <p>A CDN places your static files (images, videos, CSS, JS) on servers worldwide.</p>
            <ul>
                <li>Reduces latency by serving content from the closest location.</li>
                <li>Offloads bandwidth from your main servers.</li>
                <li>Works best for static or rarely-changing assets.</li>
            </ul>
            <hr class="blog-divider">

            <h4>üîÑ 7. Stateless vs. Stateful Servers</h4>
            <p>Statelessness is a cornerstone of scalability.</p>

            <h5><strong>Stateless Servers</strong></h5>
            <ul>
                <li>Do not store session data between requests.</li>
                <li>Each request contains all the needed information.</li>
                <li>Easy to scale because any server can handle any request.</li>
            </ul>

            <h5><strong>Stateful Servers</strong></h5>
            <ul>
                <li>Store session or user data locally.</li>
                <li>Harder to scale‚Äîyou must ensure a user's requests go to the same server (sticky sessions).</li>
            </ul>

            <p>üí° <strong>Tip:</strong> Store state in a shared session store (e.g., Redis) to keep servers stateless.</p>
            <hr class="blog-divider">

            <h4>üåç 8. Data Centers and Geo-Routing</h4>
            <p>Global systems need more than one data center.</p>
            <ul>
                <li>Geo-routing sends users to the nearest data center for speed.</li>
                <li>Provides redundancy if one center fails.</li>
                <li>The challenge: keeping data consistent across multiple regions without slowing down the system.</li>
            </ul>
            <hr class="blog-divider">

            <h4>üì® 9. Message Queues</h4>
            <p>Message queues decouple services so they can work independently.</p>
            <ul>
                <li>Producers send messages to the queue.</li>
                <li>Consumers process them at their own pace.</li>
                <li>If a consumer is offline, the message stays in the queue until it's ready.</li>
                <li>Common tools: RabbitMQ, Kafka, AWS SQS.</li>
            </ul>

            <hr class="blog-divider">

            <h4>üóÑÔ∏è 10. Database Scaling</h4>
            <p>Databases can also scale both vertically and horizontally.</p>
            <ul>
                <li><strong>Vertical scaling:</strong> Upgrade hardware.</li>
                <li><strong>Horizontal scaling:</strong> Shard data across multiple DB servers.</li>
                <li>Sharding strategy is critical‚Äîpoor choices can lead to hotspots or unbalanced loads.</li>
            </ul>
            <hr class="blog-divider">

            <h4>üí≠ Final Thoughts</h4>
            <p>Chapter 1 of <strong>System Design Interview</strong> is a crash course in the fundamental pieces of large-scale systems. From databases to CDNs, from load balancers to queues‚Äîthese are your building blocks.</p>
l

        </div>
    </div>
</body>

</html>
